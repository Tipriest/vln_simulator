# 坐标转换说明

## 1. 整体说明
`gazebo(vln-gazebo-simulator)`中的默认坐标系与`habitat(vln-simulator)`中的默认坐标系有区别

所以从`gazebo`坐标系到`habitat`坐标系需要有坐标关系和角度关系的变换，具体的变换矩阵如下所示:

## 2. 矩阵变换

2.1 `gazebo`->`habitat` 的位置坐标转换

$$
\begin{equation}
\left[
\begin{array}{c}
x_{habitat} \\
y_{habitat} \\
z_{habitat}
\end{array}
\right]
=
\left[
\begin{array}{ccc}
0 & -1 & 0 \\
0 & 0 & 1 \\
-1 & 0 & 0
\end{array}
\right]
\left[
\begin{array}{c}
x_{gazebo} \\
y_{gazebo} \\
z_{gazebo}
\end{array}
\right]
\end{equation}
$$


2.2 `gazebo`->`habitat` 的角度转换

$$
\begin{equation}
\left[
\begin{array}{c}
r_{habitat} \\
p_{habitat} \\
y_{habitat}
\end{array}
\right]
=
\left[
\begin{array}{ccc}
0 & -1 & 0 \\
0 & 0 & 1 \\
-1 & 0 & 0
\end{array}
\right]
\left[
\begin{array}{c}
r_{gazebo} \\
p_{gazebo} \\
y_{gazebo}
\end{array}
\right]
\end{equation}
$$

2.3 `habitat`->`gazebo` 的位置坐标转换

$$
\begin{equation}
\left[
\begin{array}{c}
x_{gazebo} \\
y_{gazebo} \\
z_{gazebo}
\end{array}
\right]
=
\left[
\begin{array}{ccc}
0 & 0 & -1 \\
-1 & 0 & 0 \\
0 & 1 & 0
\end{array}
\right]
\left[
\begin{array}{c}
x_{habitat} \\
y_{habitat} \\
z_{habitat}
\end{array}
\right]
\end{equation}
$$

2.4 `habitat`->`gazebo` 的角度转换

$$
\begin{equation}
\left[
\begin{array}{c}
r_{habitat} \\
p_{habitat} \\
y_{habitat}
\end{array}
\right]
=
\left[
\begin{array}{ccc}
0 & 0 & -1 \\
-1 & 0 & 0 \\
0 & 1 & 0
\end{array}
\right]
\left[
\begin{array}{c}
r_{gazebo} \\
p_{gazebo} \\
y_{gazebo}
\end{array}
\right]
\end{equation}
$$

## 3. 参考代码

3.1`gazebo`->`habitat` 的参考代码
```python
from scipy.spatial.transform import Rotation as SciRot

def euler_to_rot(roll: float, pitch: float, yaw: float) -> np.ndarray:
    """
    欧拉角 -> 旋转矩阵
    输入单位: 弧度
    顺序: Z-Y-X (yaw, pitch, roll)
    """
    # SciPy: from_euler('zyx', [z, y, x]) = [yaw, pitch, roll]
    r = R_.from_euler('zyx', [yaw, pitch, roll])
    return r.as_matrix()  # (3,3)

def gazebo_pose_callback(self, msg: Odometry):
    px = msg.pose.pose.position.x
    py = msg.pose.pose.position.y
    pz = msg.pose.pose.position.z
    ox = msg.pose.pose.orientation.x
    oy = msg.pose.pose.orientation.y
    oz = msg.pose.pose.orientation.z
    ow = msg.pose.pose.orientation.w

    # Convert quaternion to roll, pitch, yaw (in radians)
    rotation = SciRot.from_quat([ox, oy, oz, ow])
    roll, pitch, yaw = rotation.as_euler('xyz', degrees=False)

    # Print pose information with Euler angles
    print("-" * 25 + "before transformation" + "-" * 25)
    print(f"Position - x: {px:.3f}, y: {py:.3f}, z: {pz:.3f}")
    print(f"Orientation (quat) - x: {ox:.3f}, y: {oy:.3f}, z: {oz:.3f}, w: {ow:.3f}")
    print(f"Orientation (RPY) - roll: {roll:.3f}, pitch: {pitch:.3f}, yaw: {yaw:.3f} (rad)")
    print(f"Orientation (RPY) - roll: {np.degrees(roll):.1f}°, pitch: {np.degrees(pitch):.1f}°, yaw: {np.degrees(yaw):.1f}°")
    print("-" * 60)

    # 变换过程
    hab_pos = [-py, pz, -px]
    # 第1个轴对应实际的 2个对应实际的 3个
    hab_euler = [-pitch, yaw, -roll] #rpy
    hab_quat = euler_to_quat(roll = hab_euler[0],
                                    pitch = hab_euler[1],
                                    yaw = hab_euler[2])  # returns [w, x, y, z]
    hab_quat = [hab_quat[1], hab_quat[2], hab_quat[3], hab_quat[0]]# change to  [x, y, z, w]


    # Print pose information with Euler angles
    print("-" * 25 + "after transformation" + "-" * 25)
    print(f"Position - x: {hab_pos[0]:.3f}, y: {hab_pos[1]:.3f}, z: {hab_pos[2]:.3f}")
    print(f"Orientation (quat) - x: {hab_quat[0]:.3f}, y: {hab_quat[1]:.3f}, z: {hab_quat[2]:.3f}, w: {hab_quat[3]:.3f}")
    print(f"Orientation (RPY) - roll: {hab_euler[2]:.3f}, pitch: {hab_euler[1]:.3f}, yaw: {hab_euler[0]:.3f} (rad)")
    print(f"Orientation (RPY) - roll: {np.degrees(hab_euler[2]):.1f}°, pitch: {np.degrees(hab_euler[1]):.1f}°, yaw: {np.degrees(hab_euler[0]):.1f}°")
    print("-" * 60)
```

更多的关于旋转矩阵，齐次变换矩阵，四元数等相互转换的代码请参考[此处](https://github.com/Tipriest/algorithm_practice/blob/main/mymathlibs/py/pose_utils/pose_utils.py)，谢谢